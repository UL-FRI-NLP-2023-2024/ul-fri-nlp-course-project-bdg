[
    {
        "role": "user",
        "message": "Kako pa bi enostavno odprl bilokatero datoteko iz že obstoječe dat.exe(napisane vVB)?  Recimo,da hočem s to datoteko pognati nek drug program(Word,explorer,...).  Probal sem s stavkom:  Private Sub Command1_Click() LoadFile \"pot\" End Sub  pa ne dela,ker je menda samo za datoteke tipa*.rtf .  Kot error mi vrze: Sub or Function not defined ."
    },
    {
        "role": "assistant_0",
        "message": "lol poglej si mal slah ni c:/ nego c:\\  sicer pa nared neki tazga  open \"file\" for input as #1 do while not eof(1) line input #1, spremenljvika loop close #1  probi, bere pa skos po vrsticah line per line do konca datoteke (EOF)"
    },
    {
        "role": "assistant_1",
        "message": "Kaj ti sploh hočes naredit? Nisem prov dobr razumu iz tvojga pisanja... Morda b iblo ze bolje ce bi odbrnil oni '/' v '\\' ... no ja malo verjetno... dej bolj podrobno opis..."
    },
    {
        "role": "assistant_2",
        "message": "OK, zdaj pa dost' zaj.... !!!    Pisanje v izvršno datoteko???    No način seveda obstaja... V programu izdelaš generator kode, nato pa s pomočjo Win32 API funkcije CreateProcess najprej sprožiš linker, ko ta konča pa še compiler, tako da dobiš izvršno datoteko. Vsekakor pa datoteka, ki jo pridela tvoj generator ni izvršna (exe) pač pa ASCII (torej text)... Razen, če ne misliš izumljat tople vode in napisati novega compiler-ja   Izvršno datoteko kreirata linker in compiler!!!  Seveda pa ti nihče ne brani pisati v binarno datoteko, vendar ti to močno odsvetujem, če pa že na vsak način hočeš... potem moraš to v kodi tudi compiler-ju povedati !!!  Open ImeDatoteke For Binary As #intDatoteka  in potem uparbiš stavek:  Put #intDatoteka, , KarkoliŽe  Vseeno mi pa niti pod razno jasno, kaj bi ti rad pisal v izvršno datoteko."
    },
    {
        "role": "assistant_2",
        "message": "Torej... Vsekakor bi bilo lepo, če bi sedaj končno napisal, kaj TOČNO bi ti rad naredil...  To, da je izvršna (.exe) datoteka skupek inštrukcij procesorju, kaj naj počne s podatki in da bi ti pravzaprav rad izdelal datoteko s podatki (ki pa ni izvršna) smo razčistili...  Ne vemo pa kaj hočeš in ti tudi ne moremo svetovati ..."
    },
    {
        "role": "user",
        "message": "Hvala za pojasnila \"@assistant_2\". Zgleda pa, da mene samo zanima kako odprem, recimo internet explorer iz svojega programcka napisanega v VB.  Prosim za pojasnilo"
    },
    {
        "role": "assistant_0",
        "message": "API's man :))), mal po iternetu poglej ker boš 100% našu"
    },
    {
        "role": "assistant_3",
        "message": "Ce ti uporaba Win32 API funkcij ni tuja, poisci ShellExecute funkcijo v MSDN-ju.  Pa se tale konkreten primer poglej."
    },
    {
        "role": "assistant_2",
        "message": "Tukaj imaš primer kode, ki odpre in zapre \"zunanjo aplikacijo\"... Primer je iztrgan iz konteksta in verjetno boš moral malenkost modificirati kodo...  Option Explicit  '*********************************************************************************** '* Deklaracije uvoznih funkcij in procedur * '*********************************************************************************** Public Declare Function GetComputerName Lib \"kernel32\" Alias \"GetComputerNameA\" (ByVal lpBuffer As String, nSize As Long) As Long Public Declare Function GetUserName Lib \"advapi32.dll\" Alias \"GetUserNameA\" (ByVal lpBuffer As String, nSize As Long) As Long  Public Declare Function GetWindowsDirectory Lib \"kernel32\" Alias \"GetWindowsDirectoryA\" (ByVal lpBuffer As String, ByVal nSize As Long) As Long Public Declare Function GetSystemDirectory Lib \"kernel32\" Alias \"GetSystemDirectoryA\" (ByVal lpBuffer As String, ByVal nSize As Long) As Long  Public Declare Function SendMessage Lib \"user32\" Alias \"SendMessageA\" (ByVal hWnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long  Public Declare Function SetWindowPos Lib \"user32\" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long Public Declare Function ShellExecute Lib \"shell32.dll\" Alias \"ShellExecuteA\" (ByVal hWnd As Long, ByVal lpOperation As String, ByVal lpFile As String, ByVal lpParameters As String, ByVal lpDirectory As String, ByVal nShowCmd As Long) As Long Public Declare Function CreateProcess Lib \"kernel32\" Alias \"CreateProcessA\" (ByVal lpApplicationName As String, ByVal lpCommandLine As String, lpProcessAttributes As SECURITY_ATTRIBUTES, lpThreadAttributes As SECURITY_ATTRIBUTES, ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, lpEnvironment As Any, ByVal lpCurrentDriectory As String, lpStartupInfo As STARTUPINFO, lpProcessInformation As PROCESS_INFORMATION) As Long Public Declare Function WaitForSingleObject Lib \"kernel32\" (ByVal hHandle As Long, ByVal dwMilliseconds As Long) As Long Public Declare Function CloseHandle Lib \"kernel32\" (ByVal hObject As Long) As Long  Public Declare Sub ExitProcess Lib \"kernel32\" (ByVal uExitCode As Long) Public Declare Function GetExitCodeProcess Lib \"kernel32\" (ByVal hProcess As Long, lpExitCode As Long) As Long Public Declare Sub ExitThread Lib \"kernel32\" (ByVal dwExitCode As Long) Public Declare Function GetExitCodeThread Lib \"kernel32\" (ByVal hThread As Long, lpExitCode As Long) As Long  Public Declare Function GetForegroundWindow Lib \"user32\" () As Long Public Declare Function GetNextWindow Lib \"user32\" Alias \"GetWindow\" (ByVal hWnd As Long, ByVal wFlag As Long) As Long Public Declare Function FindWindow Lib \"user32\" Alias \"FindWindowA\" (ByVal lpClassName As String, ByVal lpWindowName As String) As Long Public Declare Function GetWindowTextLength Lib \"user32\" Alias \"GetWindowTextLengthA\" (ByVal hWnd As Long) As Long Public Declare Function GetWindowText Lib \"user32\" Alias \"GetWindowTextA\" (ByVal hWnd As Long, ByVal lpString As String, ByVal cch As Long) As Long Public Declare Function DestroyWindow Lib \"user32\" (ByVal hWnd As Long) As Long  Public Declare Function GetLastError Lib \"kernel32\" () As Long Public Declare Function FormatMessage Lib \"kernel32\" Alias \"FormatMessageA\" (ByVal dwFlags As Long, lpSource As Any, ByVal dwMessageId As Long, ByVal dwLanguageId As Long, ByVal lpBuffer As String, ByVal nSize As Long, Arguments As Long) As Long  '*********************************************************************************** ' Deklaracije sistemskih podatkovnih struktur * '***********************************************************************************  Public Type STARTUPINFO cb As Long lpReserved As String lpDesktop As String lpTitle As String dwX As Long dwY As Long dwXSize As Long dwYSize As Long dwXCountChars As Long dwYCountChars As Long dwFillAttribute As Long dwFlags As Long wShowWindow As Integer cbReserved2 As Integer lpReserved2 As Long hStdInput As Long hStdOutput As Long hStdError As Long End Type  Public Type PROCESS_INFORMATION hProcess As Long hThread As Long dwProcessId As Long dwThreadId As Long End Type  Public Type SECURITY_ATTRIBUTES nLength As Long lpSecurityDescriptor As Long bInheritHandle As Long End Type  '*********************************************************************************** '* Deklaracije sistemskih konstant * '***********************************************************************************  Public Const HWND_TOPMOST = -1 Public Const SWP_NOMOVE = &H2 Public Const SWP_NOSIZE = &H1 Public Const INFINITE = &HFFFF ' Infinite timeout Public Const NORMAL_PRIORITY_CLASS = &H20 Public Const SW_SHOWNORMAL = 1 Public Const GW_HWNDNEXT = 2 Public Const GW_HWNDPREV = 3 Public Const GW_HWNDFIRST = 0 Public Const GW_HWNDLAST = 1 Public Const WM_CLOSE = &H10  Public hWnd_ExternalApplication As Long Public nWnd_ExternalApplication As String  Private Proc As PROCESS_INFORMATION  Public Sub RunExternalApp(ByVal FilePath As String, CmdLn As String, SrvType As Boolean)  Dim Secure As SECURITY_ATTRIBUTES Dim Start As STARTUPINFO Dim Buffer As String Dim rc As Long  Screen.MousePointer = vbHourglass  If SrvType = IN_PROCESS Then '(znotraj obstojecega procesa)  'inicializiramo podatkovne strukture Start.cb = Len(Start) With Secure .nLength = Len(Secure) .lpSecurityDescriptor = 0 .bInheritHandle = 0 End With  'zazenemo aplikacijo rc = CreateProcess(FilePath, CmdLn, Secure, Secure, 1, NORMAL_PRIORITY_CLASS, ByVal 0, vbNullString, Start, Proc) rc = WaitForSingleObject(Proc.hProcess, 1000) 'preberemo rocico okna zunajprocesnega streznika Buffer = String(MAX_LENGTH, Chr(0)) hWnd_ExternalApplication = GetForegroundWindow  Do While Not hWnd_ExternalApplication = 0 rc = GetWindowText(hWnd_ExternalApplication, Buffer, MAX_LENGTH) If Left(Buffer, rc) = nWnd_ExternalApplication Then Exit Do hWnd_ExternalApplication = GetNextWindow(hWnd_ExternalApplication, GW_HWNDPREV) Buffer = String(MAX_LENGTH, Chr(0)) Loop  If hWnd_ExternalApplication = 0 Then hWnd_ExternalApplication = GetForegroundWindow  Do While Not hWnd_ExternalApplication = 0 rc = GetWindowText(hWnd_ExternalApplication, Buffer, MAX_LENGTH) If Left(Buffer, rc) = nWnd_ExternalApplication Then Exit Do hWnd_ExternalApplication = GetNextWindow(hWnd_ExternalApplication, GW_HWNDNEXT) Buffer = String(MAX_LENGTH, Chr(0)) Loop  Screen.MousePointer = vbDefault   Else '(zunaj obstojecega procesa)  rc = ShellExecute(0, \"Open\", FilePath, \"\", \"C:\\\", SW_SHOWNORMAL)  End If  End Sub  Public Sub TerminateExternalApp(hWnd As Long) Dim rc As Long  rc = SendMessage(hWnd, WM_CLOSE, 0, 0) rc = CloseHandle(Proc.hProcess)  End Sub  Srečno!"
    },
    {
        "role": "user",
        "message": "Ja, hvala vsem,ki se trudite. Nažalost nimam dosti pojma o Win32 API funkcijah,kernel32,itd. Obstaja kaka možnost, da bi se to na hitro skapiralo?  Mogoce kaka dobra knjiga ?"
    },
    {
        "role": "assistant_2",
        "message": "Visual Basic (R) Developer's Guide to the Win32 API, založba Sybex  Visual Basic Programers Guide to the Win32 API, založba SAM'S  Obe knjigi dobiš pri založbi Pasadena, kjer imaš omogočeno naročanje preko interneta.  Nekaj osnovnih \"fint\" pa ti posreduje tudi Aleš ŠULER v knjigi Visual Basic - zvijače in nasveti  Sicer pa lahko iz VB-ja enostavno zaženeš program: Shell \"C:Test.exe\" vendar pa niomaš nad tem programom nikakršnekontrole več... No ja, lahko mu preko SendKeys pošiljaš določene ukaze, vendar je to bolj ali manj vse...  LP"
    },
    {
        "role": "user",
        "message": "Kot zgleda enostavne poti za moj problem ni ( za mene ).Tako se bom posvetil misterioznemu WIN32 API in upal na najboljše.  Zahvaljujem se vsem, posebaj pa še \"Welbblodu\" za izčrpno pomoč.  I'll be back"
    },
    {
        "role": "assistant_2",
        "message": "Brez skrbi... zadeva je (dokaj) enostavna...   Podobno kot imajo komponente izpostavljene metode, lahko gledaš tudi na API kot na izpostavljene metode OS-a.  API pomeni pravzaprav Aplication Programing Interface... Če temu dodaš, še Win32 => Vmesnik za programiranje v 32 bitnem Windows okolju.  Funkcije so torej neke vrste \"ukazi\", ki jih pošiljaš neposredno OS-u.  Vse to je navadnim VB programerjem spretno prikrito... To te sicer obvaruje marsikaterega sesutja sistema, vendar pa ti \"kravžlja\" živce na drug način...  Kot si sam opazil, si omejen z idejami, ki so jih imeli snovalci VB-ja ob njegovem nastanku... By the way, če si ogledaš notranjo zgradbo VB RTL-ov, boš videl, da gre za pravzaprav skupek funkcij, ki kliče Win32 API funkcije... Skratka le en \"vmesnik\" več... To pa je tudi navadno tisto, kar naredi VB počasnejšega od ostalih orodij... (delo po sistemu: funkcija, ki kliče funkcijo, ki kliče neko drugo funkcijo..., ki kliče Win32 API funkcijo, ki na koncu vrne nek rezultat)   C-jaši pa naprimer API funkcije uporabljajo kot nekaj povsem naravnega.   V Delphi-ju so pri borlandu šli še korak naprej in imaš veliko večino Win32 API funkcij že vnaprej deklariranih in imaš tako občutek da delaš z \"normalnimi\" funkcijami (beri: niti se ne zavedaš, da uporabljaš Win32 API).  Za pomoč se lahko kadarkoli obrneš neposredno na mail.   Pa veliko sreče in dobrih živcev..."
    }
]