[
    {
        "role": "user",
        "message": "Pozdravljeni, Izdelujem program za vodenje evidenc. Program je spisan v pythonu, grafični vmesnik delam v qt, baza pa je postresql.  Imam pa težavo, s katero, se ukvrarjam že nekaj dni in ne najdem rešitve. Namreč v bazi imam npr. 2000 zapisnov. Iskanje imam tako narejeno, da preko grafičnega vmesnika iščem zapise. Potram išče sproti, ko vpišem eno črko, mi izpiše vse zapise, ki vsebujejo to črko, ko vpišem drugo črko, mi zoža najdene izpisi, na tiste, ki vsebujejo ti dve črko in tako naprej. Zadeva pa se zaustavi, ko pritisnem preslednico, takrat pa mi ne najde nič. npr: vpišem: ulica (brez presledaka na koncu); tukaj mi najde vse zapise, ki vsebujejo besedo ulica, lp ša vpišem: ulica (in preseledek na koncu); tukaj pa mi izbriše še tiste izpise, ki jih najde prej.  Kot sem malo raziskal, je problem v primerjavi s presledkom v postregsql bazi in presledkom v pythonu,   A ima kdo kakšno pametno idejo?  hvala."
    },
    {
        "role": "user",
        "message": "???,  kaj bi pa naj bilo to, da bi bilo dostojno 21. stoletju?"
    },
    {
        "role": "assistant_0",
        "message": "Kaksen je pa tvoj query za iskanje teh zadetkov?"
    },
    {
        "role": "user",
        "message": "Takole je, naprej preberem vse zapise, ki jih imam v tebali in v seznam shranim tiste, po katerih hočem iskati, torej navaden   SELECT row1, row2, row4 from tabel1;  Te zapise potem shranim v seznam.  v qniz, pa berem isklani niz, ki ga vnese uporabnik grafični vmensnik  qniz=main.uporLeIskanje.text()   potem za vsak pritisk tipke, se pokiče funkcija in primeraj, če je vneseni niz v bazi in če je, tiste zapise shranim v imenik.   for row in cursor: for i in row: if str(qniz).lower() in str(i).lower(): imenik.append((str((row[0])),row[1],row[2])) break"
    },
    {
        "role": "assistant_0",
        "message": "@user je 24. mar 2014 ob 09:16 izjavil:Takole je, naprej preberem vse zapise, ki jih imam v tebali in v seznam shranim tiste, po katerih hočem iskati, torej navaden   SELECT row1, row2, row4 from tabel1;  Te zapise potem shranim v seznam.  v qniz, pa berem isklani niz, ki ga vnese uporabnik grafični vmensnik  qniz=main.uporLeIskanje.text()   potem za vsak pritisk tipke, se pokiče funkcija in primeraj, če je vneseni niz v bazi in če je, tiste zapise shranim v imenik.   Torej ce te prav razumem, ti dejansko iskanje opravljas s pythonom na tvojem prej prebranem seznamu?"
    },
    {
        "role": "user",
        "message": "ja, nekako, mislim, da je takšna rešitev najhitrejša, no mogoče se motim."
    },
    {
        "role": "assistant_0",
        "message": "Potem je problem v pythonu. Naredis mogoce kaksen trim qniz spremenljivke? Sicer pa pri PostgreSQL ni problema pri iskanju s presledkom. Hitreje je verjetno zaradi tega ker program ne rabi delat toliko querijev v bazi. A nad neko velikostjo baze tudi ta pogoj odpade. Meni se zdi vseeno najboljse pri iskanju uporabljati bazo, ker lahko naredis pogojo ... WHERE \"field\" = 'iskaniString' ..., v iskalnem oknu pa lahko uporabljas nize kot so \"ulica%\", \"%ulica%\", ... in imas tako sam vecji nadzor kako dela search.  Sicer pa je ponavadi praksa, da moras vnesti vsaj \"n\" crk, preden iskalnik dela (n >= 2)."
    },
    {
        "role": "user",
        "message": "Ne nobenega trima nisem uporabil. Vendar ko sem delal debug, sem opazil,da pri podatku iz baze je v nizu \\xoA, pri pytonu pa ne, čeprav je oboje presledek mi program pri primerjavi ne dela.   Saj če ne bo durge, bom tudi sikal s pomočjo baze.  Hvala zaenkrat @WarpedOne:Čakam na tvoje predloge."
    },
    {
        "role": "assistant_1",
        "message": "Vprašanje: kaj bi pa naj bilo to, da bi bilo dostojno 21. stoletju? Odgovor: Potem je problem v pythonu.  Moj predlog: Vrži stran posrednika (python sranje) in iskanje izvedi v bazi preko klasičnih SQL poizvedb. Boš vsaj vedel zakaj ti neki ne dela. Še prej pa razišči, kaj točno se ti vpisuje v bazo - mrbit se presledki zakodirajo in potem pri primerjanju iščeš po kodiranih vrednostih. Šizofrenija zastonjske kode..."
    },
    {
        "role": "assistant_2",
        "message": "Moj predlog: Vrži stran nesmiselne predloge WarpedOne in vprašaj koga, ki dejansko zna programirat. To, kar ti počneš, je obsceno na vseh mogočih nivojih (in python tega ne spremeni, čeprav WarpedOne postane penast, ko vidi sodoben programski jezik)."
    },
    {
        "role": "assistant_3",
        "message": "Jaz ne razumem točno tele kode:  if str(qniz).lower() in str(i).lower(): Zakaj si tu uporabil in operator?  Sorry, pythona sicer ne poznam, nikoli še nisem nič naredil v pythonu, vseeno pa mislim, da želiš primerjati dva niza med sabo Če imaš torej nize Mama Mama tepe Mama tepe radiator Išeč pa niz Mama se ti zankaš skozi seznam teh nizov, in iščeš kateri če kateri element v tem seznau ustrezna nizu \"Mama\" (uporabljaš IN operator, delaš torej object comparison). Seveda dobiš zadetek, ker prvi element ustreza iskanemu.  Če pa vpišeš Mama in presledek, torej nobeden element ne ustreza iskanemu. Zdi se mi, da bi moral uporabiti neko drugo primerjavo, nekaj v smuslu  if str(i).lower.startswith(str(qniz).lower()) in operator pomoje tu primerja dva objekta med seboj, ne pa dve vredosti objektov... Lahko da sem brcnil v temo, saj pravim,ne poznam pythona."
    },
    {
        "role": "assistant_4",
        "message": "fortran + ini, dat datoteke.  @user, poglej zasebna sporočila."
    },
    {
        "role": "user",
        "message": "Ker nimam toliko pojma o pragmiranju, sem se obrnil na vas. Sam sem predvidelva, da če iz baze najprej preberem vse npr. vse naslove in ID in jih shranim v python seznam, bo potem zadeva tekla hitreje, kot pa če grem za vsako črko izvajat sql stavek.   Meni sedaj izvede sql stavek ko vnesem prvo črko v iskalno polje. Potem mi vse najdene zapise napiše v QtableWidget. Tam izberem željeni zapis in klinem na prikaži podrobnosti. Tukaj se mi izbede drugi sql stavek, ki mi prebere vse podatke iz baze. @Ilavatar: Hvala, to se mi zdi zelo dober predlog, bom sprobal in bom videl če mi bo delalo. Sam sem mislim, da je razlika med in in startwith v tem, da in išče po celem zapisu, startswith pa gre samo od začetka zapisa. Samo tudi pri in, ga ne bi smel motit presledek."
    },
    {
        "role": "assistant_2",
        "message": "@user> Ker nimam toliko pojma o pragmiranju, sem se obrnil na vas. Sam sem predvidelva, da če iz baze najprej preberem vse npr. vse naslove in ID in jih shranim v python seznam, bo potem zadeva tekla hitreje, kot pa če grem za vsako črko izvajat sql stavek.  Zelo težko boš hitrejši od baze, ker imaš podatke v bazi in jih moraš v vsakem primeru prebrati.  Če bi rad izjemno hitro splošno iskanje, potem moraš tako in tako uporabiti Lucene ali podobno knjižnico, ampak IMO v tvojem primeru to nima smisla.  Uporabi poizvedbo na bazi in poskrbi, da imaš ustrezne indekse na stolpcih, po katerih poizveduješ.   SELECT a, b, c FROM tabela WHERE a ILIKE 'niz%' OR b ILIKE 'niz%' OR c ILIKE 'niz%'"
    },
    {
        "role": "assistant_3",
        "message": "Za vsako vnos v iskalno polje sedaj opraviš poizvedbo na bazi? Zakaj se ti zdi to dobra ideja?  Enkrat je imel vodovodar pri meni idejo, ker pač ni imel pravega testnila za cev, da bo kar z izolirnim trakom prelepil cev..... ne sprašuje kaj je bilo potem.  Močno ti odsvetujem da greš za vsak pritisk tipke na bazo..."
    },
    {
        "role": "assistant_2",
        "message": "@assistant_3> Za vsako vnos v iskalno polje sedaj opraviš poizvedbo na bazi? Zakaj se ti zdi to dobra ideja?  Ker so indeksi na bazi bistveno učinkovitejše reči kot loopanje po celotni tabeli skozi python loop, ki temu ni bil nikdar namenjen."
    },
    {
        "role": "assistant_0",
        "message": "@assistant_2 je 24. mar 2014 ob 12:27 izjavil:@assistant_3> Za vsako vnos v iskalno polje sedaj opraviš poizvedbo na bazi? Zakaj se ti zdi to dobra ideja?  Ker so indeksi na bazi bistveno učinkovitejše reči kot loopanje po celotni tabeli skozi python loop, ki temu ni bil nikdar namenjen.  Cisto res. Cetudi bi imel pameten algoritem ki bi sproti cistil odvecne vnose v arraju (tako da bi z vsako vpisano črko manjsal array glede na zadetke), ne mores pohendlati ce user izbrise eno crko."
    },
    {
        "role": "assistant_1",
        "message": "In na koncu ste prišli do istega mojega predloga:  Vrži stran posrednika (python sranje) in iskanje izvedi v bazi preko klasičnih SQL poizvedb. Vmes pa še mal pumpanja lastnega ega, kako to ni ok in moderni jadajadajada.  Če prideš v situacijo ko SQL LIKE postane prepočasen, maš en širok spekter možnih ukrepov, ki stvar pospešijo. Kaj narest najprej je odvisno od konkretne vsebine in načina iskanja. Težko boš prišel v situacijo, ko bo preveč podatkov za hitro iskanje. Izvedba iskanja preko middlemana bo v taki situaciji zelo zelo hitro."
    },
    {
        "role": "assistant_3",
        "message": "Ok. Pythona ne poznam, kot sem že rekel, težko torej kaj rečem o loopanju po tabeli s pythonom... Obstaja pa tudi koncept cachinga, kjer ti nek objekt iz baze pripelješ v cache in rečeš, da je cache veljaven za neko časovno obdobje. Vsak dostop v cache preveri veljavnost cache-a in če je veljavnost potekla ga ponovno zgradiš. Posledično hitaš bazo vsakič ko cache ni več veljaven, iskanje pa izvajaš nad cache-om. Odvisno pač od situacije, nekje je cache primeren, nekje spet ni.  Moj point je, da se mi zdi neprimerno implementirat tak workaround v smislu naredimo nekaj kar deluje, hitajmo bazo za vsak pritisk tipke, ker OP ne zna poiskat v seznamu pravega elementa (sploh ker uporablja object comparison z IN operatorjem...)"
    },
    {
        "role": "user",
        "message": "Bom probal, danes popoldan sprogramirat zadeva tako, da bo za vsak pritisk tipke, šel gledat v bazo in bom videl če se bo kaj poznalo na hitrosti."
    },
    {
        "role": "assistant_2",
        "message": "@assistant_3> ker OP ne zna poiskat v seznamu pravega elementa  Ne more ga, dokler ne implementira indeksa, na moč podobnega tistemu v bazi.  WarpedOne> Vmes pa še mal pumpanja lastnega ega, kako to ni ok in moderni jadajadajada.  A to si opisoval svoje jamranje nad dvema preizkušenima in povsod prisotnima tehnologijama?  @user> Bom probal, danes popoldan sprogramirat zadeva tako, da bo za vsak pritisk tipke, šel gledat v bazo in bom videl če se bo kaj poznalo na hitrosti.  Pravilna rešitev pri delu s Qt je seveda nafilat vse v QList in uporabiti STL operator (nekaj podobnega so drugi že predlagali) - ampak preden se boš to naučil pravilno implementirati, bo baza že nekaj mesecev stregla podatke tako hitro, da bistvene razlike (v rangu do četrt sekunde na sodobnem računalniku) ne boš opazil."
    },
    {
        "role": "assistant_5",
        "message": "http://seldo.com/weblog/2011/08/11/orm_...  p.s.: Četrt sekunde je pri UI ogromno."
    },
    {
        "role": "user",
        "message": "Ja glede hitrosti, mi sedaj 2000 zapisov obrača zelo hitro. Sem presenečen nad hitrostjo, sploh, ko imamo v službi programe, ki obračajo iste podatke, veliko počasneje."
    },
    {
        "role": "assistant_2",
        "message": "@assistant_5> p.s.: Četrt sekunde je pri UI ogromno.  Drži. Še vedno manj kot pol leta, pa enkrat bo treba naložit podatke v pomnilnik. @user> 2000 zapisov obrača zelo hitro.  To baza drži v pomnilniku skupaj z indeksi in se odzove v nekaj milisekundah."
    },
    {
        "role": "user",
        "message": "Do koliko približno zapisov, bi pa bilo to smiselno, da bi delal seznam v pyhtonu. 10.000, 100.000.?"
    },
    {
        "role": "assistant_1",
        "message": "A to si opisoval svoje jamranje nad dvema preizkušenima in povsod prisotnima tehnologijama? Žalostno stanje stvari o teh zadevah pove vse kar je treba povedat - They tipicaly stink.  Za ilustracijo: ... sploh, ko imamo v službi programe, ki obračajo iste podatke, veliko počasneje. Ogromno stvari je s temi \"preizkušenimi in povsod prisotnimi tehnologijami\" narejneo obupno zanič.  2000 zapisov prebrat in držat v middlelayeru še ni nek problem. 20k načeloma tut ne, 200k je že vprašanje, 2M pa ni več niti vprašanje ali je to še OK.  Sploh ker je ta middlelayer prepogosto narejen na osnovi slikarja šlemita.  Ko testiratš dela vse super duper, v produkciji čez kak mesec stvar začne postajat neodzivna itd.  Obstaja pa tudi koncept cachinga, kjer ti nek objekt iz baze pripelješ v cache in rečeš, da je cache veljaven za neko časovno obdobje. Baza ima cache. Tipično boljšega kot katerikoli middleman.  Do koliko približno zapisov, bi pa bilo to smiselno, da bi delal seznam v pyhtonu. 10.000, 100.000.? Funkcija počasnosti ostalih delov sistema zato enoznačnega odogovora ni."
    },
    {
        "role": "assistant_2",
        "message": "WarpedOne> Ogromno stvari je s temi \"preizkušenimi in povsod prisotnimi tehnologijami\" narejneo obupno zanič.  Kar nima nobene zveze s tem, da so te tehnologije najmanj zadostne - v primeru pythona in postgresa pa vsaj primerne (se pa seveda strinjam, da niso vedno najboljše - ampak glede na to, kaj človek počne zgoraj, bi si drznil trditi, da tehnologija, ki bi mu preprečila takšne norosti, ne obstaja)."
    },
    {
        "role": "assistant_1",
        "message": "Tehnologija nikoli ne preprečuje norosti, jih pa pogosto skriva pod havbo."
    },
    {
        "role": "assistant_2",
        "message": "WarpedOne> Tehnologija nikoli ne preprečuje norosti, jih pa pogosto skriva pod havbo.   Naštej torej konkretne norosti v pythonu in postgresu, ki so skrite, prosim."
    },
    {
        "role": "assistant_1",
        "message": "Par random zadev, niti ne nujno najhujših: ...This approach is certainly safe, but it has (for the new Python programmer), a startling implication: in any Python program, no matter how many threads and how many processors are present, only one thread is being executed at any time.  Nobenega indeksiranja navadnih seznamov, ki bi lahko pospešilo iskanje: For (unsorted) lists in Python, the \"in\" operation requires O(n) time---not good when you have a large amount of data  Obstajajo hitrejše strukture, a niso brezplačne ergo vprašljiva uporabnost, ko imaš za hranit veliko vsebine: Both dictionaries and sets use hashing and they use much more memory than only for object storage. According to A.M. Kuchling in Beautiful Code, the implementation tries to keep the hash 2/3 full, so you might waste quite some memory.  Glede Postgre pa nevem kaj mi očitaš? Je baza, use it! Zamerim ji 'le' obupno štorasto nalaganje stored procedur in zapletanje s string delimiterji."
    },
    {
        "role": "assistant_2",
        "message": "Kaj pri tem je \"skritega pod havbo\"?"
    },
    {
        "role": "assistant_6",
        "message": "@assistant_1 je 24. mar 2014 ob 16:17 izjavil:Par random zadev, niti ne nujno najhujših: ...This approach is certainly safe, but it has (for the new Python programmer), a startling implication: in any Python program, no matter how many threads and how many processors are present, only one thread is being executed at any time.  Nobenega indeksiranja navadnih seznamov, ki bi lahko pospešilo iskanje: For (unsorted) lists in Python, the \"in\" operation requires O(n) time---not good when you have a large amount of data  Obstajajo hitrejše strukture, a niso brezplačne ergo vprašljiva uporabnost, ko imaš za hranit veliko vsebine: Both dictionaries and sets use hashing and they use much more memory than only for object storage. According to A.M. Kuchling in Beautiful Code, the implementation tries to keep the hash 2/3 full, so you might waste quite some memory.  Glede Postgre pa nevem kaj mi očitaš? Je baza, use it! Zamerim ji 'le' obupno štorasto nalaganje stored procedur in zapletanje s string delimiterji.  Ena stvar, ki jo v tem trenutku ne rabi je paralelizem.  Kar se tiče seznamov, za njega ne bo problem. Zahtevnejši uporabniki lahko uporabijo Numpy.  Da ne bomo preveč blodil o Pythonovi porabi pomnilnika... Si že kdaj slišal za Javo?  Back on topic. Opju priporočam, da si pogleda SqlAlchemy in si pomaga z njim. S tem mu bo omogočeno, da ne dela vsega v aplikaciji in da se ne bo rabil prekomerno zajebavat z bazo."
    },
    {
        "role": "user",
        "message": "Ja sem slišal za Javo, vendar imam navječ izkušenj s pythonom in ga najbolj obvladam. Pa tudi za aplikacijo, ki jo delam, je tudi primeren.  SQLAlchemy sem pa že tudi nekaj zasledil, ampak apklicaija sploj ni zakomplilcirana, mene je samo zanimalo, če ima kdo rešitev, zakaj mi ko pritisnem preslednico ne najde več nobenega zadetka, ampak razprava pa je šla kot bi delal aplikacijo za NASO. :), no saj je zelo zanimivo brati komentarje.  Bom pa še uporabil to temo za še eno vprašanje. Vse kar sem do sedaj programiral je bilo za enega uproabnika. To aplikacijo pa želim, da bo večuporabniška. Torej baza na serverju, na lokalnih napravah pa dostopi.   A mi mogoče lahko kdo poda kakšen link za literaturo ali kako drugače pomaga, kaj in kako moram pri programu pazit, da bo zadeva delala."
    },
    {
        "role": "assistant_6",
        "message": "No vidiš, sedaj se pa že začenjaš premikat v \"NASA\" vode.  Načeloma imaš dva pristopa. Prvi in verjetno zate boljši je, da vsakemu uporabniku narediš svojo bazo/shemo in vse ostalo ostane enako (razen koraka avtorizacije, ko uporabniške poverilnice povežeš s pravo podatkovno bazo).  Drugi pristop je, da imaš eno podatkovno bazo in potem vse preostale tabele prilagodiš tako, da bo vsak zapis vezan na lastno organizacijo ali uporabnika. Ta pristop uporabiš kadar imaš za to dobre razloge.  V resnici ti priporočam uporabo kakega frameworka npr: http://flask.pocoo.org/  p.s.: Komentar o Javi je letel na BighWhala, ki je nekaj blodil o porabi pomnilnika. Python je recimo počasen kot pes, vendar v splošnem ne žre nekih enormnih količin pomnilnika. Java je mnogo hitrejša od Pythona, vendar se mimogrede zgodi da ti požre ves pomnilnik kar ga najde."
    },
    {
        "role": "assistant_7",
        "message": "@assistant_6 je 24. mar 2014 ob 16:44 izjavil: p.s.: Komentar o Javi je letel na BighWhala, ki je nekaj blodil o porabi pomnilnika. Python je recimo počasen kot pes, vendar v splošnem ne žre nekih enormnih količin pomnilnika. Java je mnogo hitrejša od Pythona, vendar se mimogrede zgodi da ti požre ves pomnilnik kar ga najde.  Požira ga predvsem zaradi tega ker je folk pozabil na brisanje objektov ročno.  In računa da bo neporabljene objekte popucal JVM."
    },
    {
        "role": "assistant_2",
        "message": "@assistant_6> p.s.: Komentar o Javi je letel na BighWhala, ki je nekaj blodil o porabi pomnilnika  WarpedOne. BigWhale te reči še kar razume. @assistant_6> Java je mnogo hitrejša od Pythona, vendar se mimogrede zgodi da ti požre ves pomnilnik kar ga najde.   To ni lastnost Jave same po sebi."
    },
    {
        "role": "assistant_1",
        "message": "Vse kar sem do sedaj programiral je bilo za enega uproabnika. To aplikacijo pa želim, da bo večuporabniška. Torej baza na serverju, na lokalnih napravah pa dostopi. Predvidevam, da se ne bo vsak uporabnik igral samo s svojimi podatki - to je dolgcajt :) Če si bodo uporabniki sharali podatke, priporočam da ma oz. je vsak uporabnik svoj uporabnik na bazi.  A mi mogoče lahko kdo poda kakšen link za literaturo ali kako drugače pomaga, kaj in kako moram pri programu pazit, da bo zadeva delala. Pravega znanja ne boš pobral iz literature ampak skozi 'krvav švic' i.e. 1. narediš, 2. vidiš kako se obnese, 3. stuhtaš izbolšavo, 4. greš na točko 1  Glede političnega prepucavanja ... java, python, isti moderen SPOS. Nkratno ponovno izumljanje tople vode ... reši en problem, ustvari 2 nova."
    },
    {
        "role": "assistant_2",
        "message": "WarpedOne> java, python, isti moderen SPOS.  Da slišimo, kaj predlagaš kot alternativo govnu."
    },
    {
        "role": "user",
        "message": "Aha, torej:  - naredim bazo na serverju.  - V programu ustvarim npr. 5 uproabnikov, in ti uporabniki bodo tudi uproabniki baze.  - Program pa naložim na vsak client računalnik posebej, skonfiguriram pot do baze   in to je to (v grobem). aja, mogočen bi moral povedati to že čisto na začetku.   To ni WEB aplikacija, to je program za delo v podjetju in je offline, razen v mreži podjetja, kjer bo več uporabnikov."
    },
    {
        "role": "assistant_4",
        "message": "a tiste zadeve, kot ste pravili (da je poizvedba v bazo hitrejsa kot drzanje v memory) veljajo tudi, ce je baza na networku oz. če je baza access?"
    },
    {
        "role": "assistant_2",
        "message": "@user> - Program pa naložim na vsak client računalnik posebej, skonfiguriram pot do baze   Uporabniško ime in geslo nastaviš na strežniku, dodeliš pravice, uporabnik naj ga pa vnese ob vsakem zagonu programa. @user> To ni WEB aplikacija, to je program za delo v podjetju in je offline, razen v mreži podjetja, kjer bo več uporabnikov.  Razumem, ampak danes morda ne bi bilo napak, če bi bila web aplikacija. @assistant_4> a tiste zadeve, kot ste pravili (da je poizvedba v bazo hitrejsa kot drzanje v memory) veljajo tudi, ce je baza na networku oz. če je baza access?   Zelo odvisno od podatkov, njihove količine in drugih lastnosti."
    },
    {
        "role": "user",
        "message": "@assistant_3 je 24. mar 2014 ob 12:11 izjavil:Jaz ne razumem točno tele kode: if str(qniz).lower() in str(i).lower(): Zakaj si tu uporabil in operator?  Sorry, pythona sicer ne poznam, nikoli še nisem nič naredil v pythonu, vseeno pa mislim, da želiš primerjati dva niza med sabo Če imaš torej nize Mama Mama tepe Mama tepe radiator Išeč pa niz Mama se ti zankaš skozi seznam teh nizov, in iščeš kateri če kateri element v tem seznau ustrezna nizu \"Mama\" (uporabljaš IN operator, delaš torej object comparison). Seveda dobiš zadetek, ker prvi element ustreza iskanemu.  Če pa vpišeš Mama in presledek, torej nobeden element ne ustreza iskanemu. Zdi se mi, da bi moral uporabiti neko drugo primerjavo, nekaj v smuslu if str(i).lower.startswith(str(qniz).lower()) in operator pomoje tu primerja dva objekta med seboj, ne pa dve vredosti objektov... Lahko da sem brcnil v temo, saj pravim,ne poznam pythona.   tudi če uporabnik startswith, je enako,ko pritisnem preslednico ni več nobenih zapisov, kot da preslednici iz baze in iz isklanega niza nebi bile enake."
    },
    {
        "role": "assistant_6",
        "message": "@assistant_4 je 24. mar 2014 ob 17:04 izjavil:a tiste zadeve, kot ste pravili (da je poizvedba v bazo hitrejsa kot drzanje v memory) veljajo tudi, ce je baza na networku oz. če je baza access?  Držanje v memoryju je hitrejše od VI nprave (disk), kar je hitrejše od networka.  Problem, ki ga izpostavjamo mi je ta da če vse podatke pumpaš v aplikacijo jih tam obdeluješ in pumpaš nazaj, potem podatkovno bazo uporabljaš praktično kot zelo drag (počasen) file sistem.  Če imaš dovolj malo podatkov in enostavno aplikacijo razlika praktično ni opazna. Če imaš podatke na networku ali bog ne daj nekje v internetu, potem pa hitro ugotoviš da to ne dela najbolje in poskušaš preko networka prenašat čim manj podatkov."
    },
    {
        "role": "assistant_8",
        "message": "@assistant_5 je 24. mar 2014 ob 13:34 izjavil:http://seldo.com/weblog/2011/08/11/orm_...  p.s.: Četrt sekunde je pri UI ogromno.  Hvala bogu za anti-pattern. Dokler si hitrejši od naše sposobni branja sprememb si OK. Za četrt sekunde bo prej krivo vse ostalo kot pa ORM :) Manjka samo še folk, ki bo rekel, da bi njemu vse hitreje delalo v assemblyerju. Ampak dokler bo on končal zadevo bo stranka ne samo že brala podatke iz pythona...vmes bo verjetno že 3 verzije OSja zamenjala če ne celo službe, kjer potrebe po programu sploh ne bo več :)   @assistant_4 je 24. mar 2014 ob 17:04 izjavil:a tiste zadeve, kot ste pravili (da je poizvedba v bazo hitrejsa kot drzanje v memory) veljajo tudi, ce je baza na networku oz. če je baza access?  Odvisno od števila podatkov in tvojega računalnika. Evo en debilen primer za folk, ki je navajen naredil \"SELECT * FROM blabla\" in se potem s podatki igrat v memoryju. Kaj bo naredil, ko bo teh podatkov za par GB. Kaj bo naredil če pade prepustnost mreže. V vsakem primeru se ti splača aplikacijo napisat tako, da poizvedbe dela baza. Maš n-bar, ki jih lahko uporabljaš lokalno. Celo flat file based. Če te srce ne boli preveč in te ni sram uporabit kakšen framework, ki omogoča uporabo različnih baz lahko, ko podatki presežejo sposobnosti uporabnikovega računalnika zadevo preprosto preseliš na nek namenski strežnik, kjer teče nek SQL strežnik(ne se kregat, ker je najboljši...). Brezveze se je že v štartu streljat v koleno. Pa tko kot je @assistant_2 napisal...če program glih ne dela ne vem česa (super 3d efektov in nekih zajebanih api klicev na komponente, ki so na klientovem računalniku ali uporablja kakšne COM pizdarije tretje stranke) potem se splača resno razmislit o WEB aplikaciji. Razen če ti je res v interesu izstavljat račun, ker moraš vsakič na 200 mašin štimat posodobitve(se opravičujem če glede na \"kodo\", ki sem jo prebral v temi napačno sklepam, da avtomatičnih posodobitev verjetno ni)."
    },
    {
        "role": "assistant_4",
        "message": "aha, hvala. se mi je zdelo, da bo nekako tako ja. sicer res nebi bilo nic napak, ce bi bila tist web app (responsive), so te dandanes moderne ravno za take namene."
    },
    {
        "role": "user",
        "message": "Glede aplikacije so zadeve določene. Določena je vsebina in funkcionalnost , na meni je samo izvedba.   Vem, da bi bila web app bolj široko uporabna, vendar pa zaenrakt je prioriteta ne web app.  Glede isklanega niza, ki je bilo moje vprašanje pri odprtju teme, sem se odločil, na podlagi vaših mnenj, ta bom vseeno raje šel vsak klic v bazo, kot pa da naložim prvo v python seznam in potem primerjam. Vendar me sedaj ne dela tako kot bi hotel. Query je takšen: cursor.execute(\"\"\" SELECT \"eDimnikar\".uporabnik.sifra_stara, \"eDimnikar\".uporabnik.naziv_1, \"eDimnikar\".uporabnik.naslov FROM \"eDimnikar\".uporabnik WHERE \"eDimnikar\".uporabnik.naslov LIKE '%%{}%%' \"\"\").format(qniz)  ampak dobim error: AttributeError: 'NoneType' object has no attribute 'format'"
    },
    {
        "role": "assistant_2",
        "message": "cursor.execute praviloma vrne število vrnjenih vrstic, ne niza.  cursor.fetchall() vrne seznam vseh vrstic."
    },
    {
        "role": "user",
        "message": "Vem,da imam nekje napako pri zapisu, ker če dam npr.   cursor.execute(\"\"\" SELECT \"eDimnikar\".uporabnik.sifra_stara, \"eDimnikar\".uporabnik.naziv_1, \"eDimnikar\".uporabnik.naslov FROM \"eDimnikar\".uporabnik WHERE \"eDimnikar\".uporabnik.naslov LIKE '%CEL%' \"\"\")  imenik = [] for item in cursor: imenik.append(item) print(imenik)  Dobim rezultate, če pa hočem prebrati niz iz tipkovnice pa mi napiše tisti error"
    },
    {
        "role": "assistant_2",
        "message": "Ker poskušaš formatirat tisto, kar vrne cursor.execute. Oklepaj imaš postavljen narobe."
    },
    {
        "role": "user",
        "message": "ja, hvala. Sedaj razumem.  Ampak. Problem je enak kot na začetku. Ko pritisnem presledek več ne dobim novenih zadetkov, ko da bi line Edit od Qt imel drug znak za presledek kot v bazi."
    }
]