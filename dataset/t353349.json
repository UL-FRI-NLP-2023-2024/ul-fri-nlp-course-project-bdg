[
    {
        "role": "user",
        "message": "uporabljam NTFS   torej ce file moveam iz enega folderja v drugega na isti particiji se dejansko popravi samo nekaj v ntfs tabeli.. right podatki na disku ostanejo na istem mestu zapisani... in ker se nic ne premika nikamor je moznost korupcije podatkov nicna  ce pa bi file premikal iz particije na particijo alipa iz diska na drugi disk bi najprej pol ure skrtalo in enke in nule bi bile prepisane in ce bi se kje kaksna napaka zgodila in bi se kaksna enka spremenila v nulo bi file ne bil vec identicen...  ok ni problema.. v tem primeru pač počekiraš crc... ali pa md5 in je  -....  jaz pa bi rad ne cekiral CRC za file ki se dejansko niso fizicno moveali po disku  moja ideja je da se počekira LBA adress od filea na disku zanima me pa kako lahko v c# na ntfs disku ugotoviš za nek file LBA naslov ... in potem kasneje če ima nek file isto ime in isti size in isti date created in modified itd itd... samo da je sedaj v drugem folderju (ampak se vedno na isti particiji)... potem bi lahko pocekiral ta LBA adress in ce bi bil LBA adress identicen kot prejsnjič ko si preverjal ta file bi lahko zaključil da gre za identicen file brez da bi celoten file prebiral in računal CRC oz MD5   tole z LBA je pac moja ideja ki mi tako na hitro pade na pamet .. sploh nevem ce diski imajo LBA - mislim da sem na to pri cdjih naletel... ampak gre za koncept tega kje se nahaja file fizicno na disku....  najverjetneje obstaja kaksen bolj smiselen pristop .... mogoce kaksna steviljka entrija v ntfs tabeli kjer se pri moveanju filea samo spremeni file adressa v temu entriju osnovna steviljka entrija pa ostane ista.... oz nekaj v tem smislu... vse to so moja ugibanja na slepo  hvala"
    },
    {
        "role": "assistant_0",
        "message": "Mislim da to nebo šlo. Ti napišeš program, in ta program deluje potem v uporabniškem načinu izvajanja (programu ni dovoljeno izvajati sistemskih stvari), sistemske stvari lahko izvaja le sam OS v t.i. nadzorniškem (priviligiran) načinu izvajanja.  Torej na kratko povedano mislim da ti OS nebo pustil šariti po disku. Če se motim naj me nekdo popravi."
    },
    {
        "role": "user",
        "message": "saj jaz nočem šariti po disku..... hočem samo nek identifier da vem da gre za isti file na isti fizicni lokaciji na disku ceprav je zdaj v drugem direktoriju na isti particiji... da gre za iste enice in nule na disku ki se nikoli niso nikamor premikale(kar pomeni da je nična verjetnost da so se spremenile -če pa je nekdo odprl stream do filea in prepisoval enke in nule potem se bo to poznalo pri last modified date)....  uglavnem jaz samo hocem da OS pove lokacijo fajla na disku... iz cesar lahko sklepam da ce je lokacija se vedno identicna in tudi last modified date in size ... samo file se je morda renameal in spremenil direktorij... da gre se vedno za en in isti file.. in mi ni treba crc checkirati  ce pa se je file dejansko premikal med particijami ali celo diski... ali pa ce je morda nekdo file presnel na drugi disk in potem nazan na isti disk na isto particijo in se je zdaj posnel na nek drugi fizicni del te iste particije bi se to moralo poznati v LBA poziciji na disku (razen če ga je slučajno res na identično mesto skopiral nazaj)...  upam da je jasno kaj hočem"
    },
    {
        "role": "assistant_1",
        "message": "OK. Kaj boš pa naredil, ko ti bo avtomatična optimizacija premešala sektorje? Ko ti jih bo defragmentacija premaknila?  Ne računaj nizko-nivojske podatke, ker so običajno prekriti z dobrim razlogom.  Če pa že po vsej sili rineš v težave, potem pa pozabi na C# in poglej Win32 API-je, ki jih lahko kličeš z \"P/Invoke\".  Funkcija, ki ti bo morda pomagala je GetFileInformationByHandle, ki vrne podatke v strukturi BY_HANDLE_FILE_INFORMATION. Polji, ki ju potrebuješ sta nFileIndexHigh in nFileIndexLow.  To ti pomaga pri iskanju identičnih datotek z več povezavami v imenik, morda pa ti bo z nekaj sreče to pomagalo uporabiti tudi za preverjanje, če se gre samo za premaknjeno datoteko. Interno je to na NTFS res samo sprememba imeniških povezav, ne pa tudi atributov vsebine. YMMW. Testiraj, pa sporoči kaj boš odkril."
    },
    {
        "role": "user",
        "message": "yup... thanks bluerunner... sem pogledal in mi je uspelo usposobiti..  se sreca da sem ze izkusen z pinvoke....  sem malo brkal in na koncu vse potrebno nasel tukaj  http://www.dreamincode.net/forums/showt... //skopirajte ta PInvokeWin32Api class.. notri je vse  ... handle dobis iz Filestream...  PInvokeWin32Api.BY_HANDLE_FILE_INFORMATION BHFI = new PInvokeWin32Api.BY_HANDLE_FILE_INFORMATION(); FileStream FS = File.OpenRead(\"test.txt\"); IntPtr hnd = FS.Handle; ; PInvokeWin32Api.GetFileInformationByHandle(hnd, out BHFI);   in evo.. takole dobis file FileIndexHigh in Low in sem probal moveati file po particiji in ostaneta indexa ista.... potem sem pa moveal file na drugo particijo in nazaj... in sta se indexa spremenila.... torej ce je vse enako razen direktorija in imena lahko sklepam da gre za isti file ki se je moveal po isti particiji in mi ni treba CRC poganjati"
    },
    {
        "role": "assistant_1",
        "message": "Lepo, da ti deluje. Vendar moje uvodno opozorilo še vedno velja. Številka se lahko mimogrede spremeni, tudi zaradi drugih razlogov na katere ne moreš vplivati ali jih zaznati. Upoštevaj tudi to pri svoji kodi."
    },
    {
        "role": "assistant_2",
        "message": "Hm, ce se bo spremenil en bit ali pa en bajt informacije v tej datoteki ali bo ta index ostal isti? Ker ce bo ostal isti, potem se je tebi file spremenil, ti pa te spremembe ne bos detektiral."
    },
    {
        "role": "assistant_1",
        "message": "Indeks bo ostal isti. Ampak v tem primeru se spremeni datum zadnje spremembe, kar sem razumel, da bo preveril preden bo naredil korak na to varianto.  Sicer pa ja... tehnično se da nekaj narediti, vendar pa se lahko človek hitro ustreli v nogo. Microsoft je samo jasno dokumentiral, da številka ni stabilna, ni pa povedal na kakšen način in v kakšnih okoliščinah vse pride do sprememb.  Če se želi ustreliti v nogo, se bo pač ustrelil... če pa ve kaj dela, pa ima na voljo relevantno pomoč."
    },
    {
        "role": "assistant_3",
        "message": "Ti ne gledas ali je dolocen file spremenjen ali ne. To bi najbrz lahko odkril po kaksnem timestampu.   Ideja je v tem, da bi odkril, ce je ena datoteka samo premaknjena verzija druge (recimo preimenovana datoteka) in to brez da bi gledal vsebino. Se pravi poznas \"fileindex\" (ala inode number) originalne in pogledas, ce je slucajno se kje datoteka s to stevilko. Ce je, je velika verjetnost, da je to originalen file. Za kaj bolj natancnega bi moral preverti checksum. Stevilka je sicer res per file in je najbrz defragmentacija ne prizadane, je pa problem ker se cez cas lahko isti id reusa za kaksen cisto drug file. Ce se ti druga datoteka spremeni za samo en bit ti pa itak tudi checksum ne koristi kaj dosti. Moral bi narediti prav diff (in torej imeti nekje shranjeno staro verzijo datoteke)."
    },
    {
        "role": "assistant_4",
        "message": "Checksum ti seveda koristi, saj so namenoma narejeni tako, da se ob spremembi samega bita _zelo_ spremenijo."
    },
    {
        "role": "assistant_3",
        "message": "Ja avalanche effect - ravno zato ne mores po checksumu reci fileA in fileB se razlikujeta samo v 1 bitu. Rabil bi originalno datoteko za primerjavo, cesar pa naceloma nimas."
    },
    {
        "role": "assistant_1",
        "message": "Defragmentacija ti potencialno lahko spremeni številko v indeksu. Pač v primeru, da se v procesu preuredi tudi MFT. Druga težava je SIS, če je ta slučajno nameščen na strežniku, ker ta tudi manipulira neposredno z MFT-jem. VSS morda lahko povzroči dodatne spremembe, morda pa tudi ne.  V glavnem je vse skupaj precej nedokumentirano in zanašanje samo na to številko je običajno Slaba stvar™. Vendar pa, če človek ve kaj počne, je to lahko tudi zelo dober pripomoček. Ta številka pač ni stabilna, z svemi posledicami, ki jih ta lastnost prinese."
    },
    {
        "role": "assistant_2",
        "message": "Takrat, ko clovek zabrede tako globoko se mora vprasati kaj sploh dela in ce to v resnici potrebuje. :> Ker takale telovadba ze kaze na to, da je nekje drugje v procesu nekaj zavozeno. :)  Ni pa to nujno res."
    }
]