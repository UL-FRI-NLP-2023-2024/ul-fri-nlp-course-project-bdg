[
    {
        "role": "user",
        "message": "Forkana debata iz  Zamenjava Javascripta"
    },
    {
        "role": "assistant_0",
        "message": "Javascript zgleda kot nekaj kar si je nekdo zmislu za seminar iz programskih jezikov na dodiplomcu.  Temu primerno je premisljen ta jezik. Ker je bil to edini jezik na voljo za client side izvajanje so ga vsi pograbili in se je razbohotila zadeva, se vedno ima pa isto sfaljeno zasnovo. Zgodba PHP ubistvu. Iz majhnega hobi skriptnega jezika se je folk spravil delat vse zivo, tudi server-side.  Sedaj njegovi uporabniki posteriorno definirajo jezik kot eleganten oziroma ekspresiven. Kar je nerd-code za hackish - torej hitro masenje stvari skupaj, kar potem lahko samo se v kos vrzes, ce je treba kasneje kej spreminjat. Ce ti en CL hipster rece da je najdu ekspresiven jezik to pomeni, da gre za jezik, ki postane tezko obvladljiv takoj ko na kodi zacne delat vec kot en clovek oziroma ko ta preseze 10000 vrstic. Regularni izrazi so tudi ekspresivni, samo cez pol leta ne bos vec razvozlal kva si hotu."
    },
    {
        "role": "assistant_1",
        "message": "@assistant_0: http://brendaneich.com/2010/07/a-brief-...  Glej od 5:00 dalje.  JavaScript je nastal v 10 dneh. Mišljen je bil kot lisp-like, vendar so kasneje šefi zahtevali, da mora biti podoben javi. Zato je javascript videt kot lisp v ALGOL obleki, ker to dejansko je.  JavaScript je en najlepših jezikov, če odmisliš sintakso."
    },
    {
        "role": "assistant_2",
        "message": "@assistant_0 je 6. jan 2012 ob 19:38 izjavil:Javascript zgleda kot nekaj kar si je nekdo zmislu za seminar iz programskih jezikov na dodiplomcu.  Temu primerno je premisljen ta jezik. Ker je bil to edini jezik na voljo za client side izvajanje so ga vsi pograbili in se je razbohotila zadeva, se vedno ima pa isto sfaljeno zasnovo. Zgodba PHP ubistvu. Iz majhnega hobi skriptnega jezika se je folk spravil delat vse zivo, tudi server-side.  Sedaj njegovi uporabniki posteriorno definirajo jezik kot eleganten oziroma ekspresiven. Kar je nerd-code za hackish - torej hitro masenje stvari skupaj, kar potem lahko samo se v kos vrzes, ce je treba kasneje kej spreminjat. Ce ti en CL hipster rece da je najdu ekspresiven jezik to pomeni, da gre za jezik, ki postane tezko obvladljiv takoj ko na kodi zacne delat vec kot en clovek oziroma ko ta preseze 10000 vrstic. Regularni izrazi so tudi ekspresivni, samo cez pol leta ne bos vec razvozlal kva si hotu.   Ja, ni premišljen jezik in vsebuje veliko neumnosti. Ampak se jim lahko izogneš. Če znaš dobro dokumentirat svojo kodo in slediš dobri praksi, je enostavno delat tud na večjih projektih. Je pa res, da nikjer ne najdeš grše kode, kot jo dopušča JavaScript. To je delno problem jezika, ki to dopušča, ampak odgovornost za pisanje pregledne kode je na programerju. V kateremkoli jeziku.  To, da se je folk spravil delat vse živo in da je JS uspešen tudi server-side ni downside jezika, ampak pokaže, da je zmogljiv. Čeprav je nastal precej na horuk in nepremišljeno. Tudi nepremišljene stvari bomo sčasoma vrgli ven in dobili zares dober jezik. Pametne alternative za izvajanje v browserju ni. Java je šla v direkten napad na web, pa vsi vemo, da se je končalo v solzah."
    },
    {
        "role": "assistant_1",
        "message": "Fantje ne mešat JavaScripta in DOM modela. Ta je pravi kripl in nima kaj dosti z JS razen tega, da je JS orodje katero ga manipulira."
    },
    {
        "role": "assistant_3",
        "message": "Mene pri JS samo moti, ker out-of-the-box ne omogoča konvencionalnega objektenga programiranja (classi). Sej je nice tudi njihov model z objekti, ampak če si navajen, včasih hočeš nrdit \"normalno\". Sej obstajajo razne knjižnice, ki to bolj ali manj uspešno omogočajo, pa vseeno. Drugače mene Javascript ful spominja na Ruby, kar se objektnega modela tiče, sam da imaš v Rubyju tudi možnost te bolj konvencionalne opcije. Zato CoffeeScript zgleda tudi cool"
    },
    {
        "role": "assistant_1",
        "message": "Od kdaj je pa java stil \"normalen\"?  Raje napiši, da si prelen, da bi zlezel iz svoje škatlice in se naučil drugačnih načinov razmišljanja."
    },
    {
        "role": "assistant_4",
        "message": "One word kidz...NodeJS  run along now..."
    },
    {
        "role": "assistant_3",
        "message": "@assistant_1 je 6. jan 2012 ob 20:27 izjavil:Od kdaj je pa java stil \"normalen\"?  Raje napiši, da si prelen, da bi zlezel iz svoje škatlice in se naučil drugačnih načinov razmišljanja.  Sej sem napisal, bolj konvencionalen. Če mi pri temu želiš oporekat potem očitno ne poznaš prav veliko jezikov. Pa tudi nikoli nisem rekel, da ne znam delat z Javascriptovim objektnim modelom, rekel sem samo da je to edina stvar ki me moti pri JS, da ne OMOGOČA out-of-the-box konvencionalnega pristopa k objektnem programiranju. Glede na to da 90% objektno orientiranih jezikov ima zelo podoben objektni model kot npr. Java (če jo že želiš izpostavit), mislim da ni nobenega dvoma da je to trenutno najbolj običajen način programiranja. Nisem pa nikoli rekel, da je slab ta pristop ki ga ima Javascript.  3. Če še ni dovolj hitro začneš gledat kak Fortran. lol? zakaj bi fortran compiler produciral program z boljšimi performancami kot c compiler?"
    },
    {
        "role": "assistant_1",
        "message": "Sej sem napisal, bolj konvencionalen. Če mi pri temu želiš oporekat potem očitno ne poznaš prav veliko jezikov. Pa tudi nikoli nisem rekel, da ne znam delat z Javascriptovim objektnim modelom, rekel sem samo da je to edina stvar ki me moti pri JS, da ne OMOGOČA out-of-the-box konvencionalnega pristopa k objektnem programiranju. Glede na to da 90% objektno orientiranih jezikov ima zelo podoben objektni model kot npr. Java (če jo že želiš izpostavit), mislim da ni nobenega dvoma da je to trenutno najbolj običajen način programiranja. Nisem pa nikoli rekel, da je slab ta pristop ki ga ima Javascript.   Dovolj jezikov poznam in sem uporabljal, da ko mi nekdo Javo omenja kot \"kako naj bi stvari izgledale\" dobim vrtoglavico, se začnem tresti in besno iščem izhod.  To da govoriš o neki \"konvencionalnosti\" je zame indikator, da slabo poznaš jezike, njihove filozofije in zgodovino.  LISP, Perl, Fortran, Java, C, Prolog, BASIC - daj povej mi kateri od teh je \"nekonvencionalen\", potem pa to utemelji.    3. Če še ni dovolj hitro začneš gledat kak Fortran.   lol? zakaj bi fortran compiler produciral program z boljšimi performancami kot c compiler? Ta nasvet ni bil iz izkušenj, ker se s tovrstnim programiranjem nisem ukvarjal, sem pa večkrat zasledil, da je Fortran za matematično zahtevne operacije boljši/hitrejši, deloma zaradi namenskih knjižnic, deloma pa zaradi zasnove. Ko si pa že tako razgledan, boš pa verjetno pomagal kolegu in meni tudi, ter napisal malo boljšo utemeljitev zakaj ni tako, kot pa zgolj \"Lol\".  Hvala ti lepa."
    },
    {
        "role": "assistant_3",
        "message": "A ti pa tako dobro poznaš jezike, ali samo rad govoriš? Utemelji potem kako lahko rečeš da je objektni model v Javascriptu običajen, potem se pa lahko naprej pogovarjamo. To nima prav nobene povezave z filozofijo in zgodovino jezika. Redkokateri jezik ima podoben objektni model kot Javascript, torej ni običajen. End of story. Pa ne vem kje si ti videl da sem jaz Javo omenjal, to si jo ti ven privlekel. Če je nekaj običajno pa tudi ne pomeni, da je dobro.  Za Fotran sem ti že utemeljil. Tako C kot Fotran se prevedeta v machine code tako da ni prav nobenega razloga da bi bil en program hitrejši od drugega, razen če je compiler za enega toliko boljši. Ampak v primeru C močno dvomim, da so optimizacije slabše od Fotran prevajalnikov, vsaj ne bistveno.  Da bi zadevo paraleliziral v brskalniku ali pa celo iz jave prevajal v NodeJS je neumnost. Zakaj bi bila neumnost? Zakaj bi obremenjeval strežnik če lahko namesto tega obremeniš PC uporabnika? V končni fazi narediš Java applet in je zadeva rešena."
    },
    {
        "role": "assistant_5",
        "message": "nič ni bolj običajno, je samo bolj razširjeno"
    },
    {
        "role": "assistant_3",
        "message": "sej to je eno in isto"
    },
    {
        "role": "assistant_5",
        "message": "čisto odvisno iz katere pesrpektive gledaš (Java -> JS ali JS -> Java ipd.)"
    },
    {
        "role": "assistant_3",
        "message": "Nič ni odvisno... Če imaš 30 jezikov z enim pristopom in 1 jezik z drugim pristopom, je prvi bolj razširjen in s tem tudi bolj običajen. Kaj je običajno ni stvar osebnega mnenja. Če je običajno reči prosim če ti nekdo reče hvala, potem je to običajno ne glede na to ali ti to osebno počneš. Običajno je pa zato ker se je dovolj razširilo med ljudmi. Sicer pa ne vem kaj se zdaj v besede spuščate ker bi moralo bit vsakemu jasno, kaj je bilo mišljeno."
    },
    {
        "role": "assistant_6",
        "message": "@assistant_3 je 7. jan 2012 ob 15:45 izjavil:Za Fotran sem ti že utemeljil. Tako C kot Fotran se prevedeta v machine code tako da ni prav nobenega razloga da bi bil en program hitrejši od drugega, razen če je compiler za enega toliko boljši. Ampak v primeru C močno dvomim, da so optimizacije slabše od Fotran prevajalnikov, vsaj ne bistveno.   http://stackoverflow.com/questions/1461...  Skratka, za numerično kodo je bistveno lažje napisat dober fortran compiler kot pa dober c compiler in dolgo so tudi bili boljši za fortran."
    },
    {
        "role": "assistant_3",
        "message": "No ja, če pogledaš prvi odgovor, tisti primer je bil odpravljen v C99. To je bilo 12 let nazaj. Seveda dokler je bil C nov jezik so bili Fortran compilerji brez dvoma boljši. Samo ti časi so že daleč daleč mimo. Predlagat nekomu, da prepiše nekaj iz C v Fortran za boljše performance je kar malo smešno."
    },
    {
        "role": "assistant_1",
        "message": "@assistant_3...  Nobene utemeljitve še nisi dal, niti nisi nič prispeval v temo. Vse kar delaš je trolanje in spreobračanje besed.  Pravi Farizej."
    },
    {
        "role": "assistant_7",
        "message": "ti gre v nos to, da java sploh obstaja, al kako?   Ker men se zdi, da tud ti dosti trollaš. jbg, java stil pač je \"normalen\" za večino ljudi pod tem soncem. Lahko se s tem sprijazniš al pa vsak pogovor obrneš v osebno križarsko vojno proti vsemu, kar je javalike.  dragi avtor teme: jst ti priporočam .NET, iz čiste žlehnobe, ker me zanima, na kake odzive bom v tem primeru naletel. :D"
    },
    {
        "role": "assistant_1",
        "message": "ti gre v nos to, da java sploh obstaja, al kako?  Ker men se zdi, da tud ti dosti trollaš. jbg, java stil pač je \"normalen\" za večino ljudi pod tem soncem. Lahko se s tem sprijazniš al pa vsak pogovor obrneš v osebno križarsko vojno proti vsemu, kar je javalike.  dragi avtor teme: jst ti priporočam .NET, iz čiste žlehnobe, ker me zanima, na kake odzive bom v tem primeru naletel. :D   Mi gre malo v nos Java ja, to je zelo očitno. In ne bom niti trdil, da imam racionalne razloge, čeprav se lahko potrudim.  Zame je Java tam nekje s COBOLom, in sem mnenja da prekomerno programiranje v Javi povzroča trajne možganske poškodbe. Trditi, da je nekaj \"normalno\" zato ker vsi to počnejo, je pa hecno. Lahko rečeš, da je popularno ne pa da je pravilno. In na tej točki se je prepir v tej temi začel. Želel sem utemeljitev zakaj je nekaj proper v odgovor sem pa dobil zgolj napade.  Obtožuješ me trolanja, torej meniš da ne sodelujem konstruktivno v tej temi? Prosim, podaj bolj relevantne informacije, če jih imaš.  Kar se .NET tiče, pa bi se tudi jaz strinjal. Za razliko od Jave mi je .NET všeč, ker ne sili ljudi v nenormalne vzorce razmišljanja."
    },
    {
        "role": "assistant_3",
        "message": "Meh... Use sem lepo utemeljil. Samo tebi se ne da čisto nič dopovedat. Se posljavljam iz teme. LP"
    },
    {
        "role": "assistant_5",
        "message": "@assistant_1 je 7. jan 2012 ob 17:48 izjavil: Kar se .NET tiče, pa bi se tudi jaz strinjal. Za razliko od Jave mi je .NET všeč, ker ne sili ljudi v nenormalne vzorce razmišljanja.   Saj ni Java edin jezik ki teče na JVM"
    },
    {
        "role": "assistant_1",
        "message": "Saj ni Java edin jezik ki teče na JVM  Res je, vendar je edini 100% podprt, ostalo je bolj akademske narave in v tem oziru je .net boljša platforma. Sicer pa moram poudarit, da se mi JVM zdi inženirsko čudo in vsaka čast fantom, ne maram zgolj Jave kot jezika ker se mi zdi izrazno omejen.  Meh... Use sem lepo utemeljil. Samo tebi se ne da čisto nič dopovedat. Se posljavljam iz teme. LP  Midva sva zabredla v en prepir kaj je boljše, povsem brezveze ker je stvar osebnih preferenc. Tebi je ljubši ALGOL stil, prav cenim to. Moja osebna preferenca je pa napram dinamičnim jezikom, ki omogočajo funkcijsko programiranje. Tvoje utemeljitve se mi pa zdijo pomanjkljive in na nivoju cargo cult znanosti (zato ker je najbolj popularna/\"Justin Timberlake\", C in Fortran sta enako hitra ker se prevajata v strojno kodo), zato jih ne morem sprejeti.  Lambda račun vs Turingov stroj. Deklarativno vs Imperativno. S prvim pristopom je elegantnejše delo z množicami z drugim pa se da lepše izraziti kontrolne strukture.  Recimo en komentar: http://antigreen.org/vadim/ProgLanguage..."
    },
    {
        "role": "assistant_5",
        "message": "@assistant_1 je 7. jan 2012 ob 18:38 izjavil: Res je, vendar je edini 100% podprt   In kaj pomeni 100% podprt? :)"
    },
    {
        "role": "assistant_1",
        "message": "To pomeni, da so ostali jeziki na JVM bolj akademske narave. Sam teh ostalih jezikov ne bi uporabljal v komercialne namene, razen za kakšen podsistem v primeru, ko recimo s Scheme lažje oz. lepše izraziš rešitev."
    },
    {
        "role": "assistant_5",
        "message": "Scala, Groovy, Jruby, ipd. so akademske narave? :)"
    },
    {
        "role": "assistant_8",
        "message": "Scala je predvsem akademska rešitev ja :)  Oftopic: Kolko pa se to drugače uporablja v slo(Scala, Groovy, Jruby)?"
    },
    {
        "role": "assistant_5",
        "message": "@assistant_8 je 8. jan 2012 ob 11:47 izjavil:Scala je predvsem akademska rešitev ja :)    zakaj točno?"
    },
    {
        "role": "assistant_1",
        "message": "Scala, Groovy, Jruby, ipd. so akademske narave? :)   Scala: http://flyingfrogblog.blogspot.com/2010... http://alblue.bandlem.com/2007/06/java-...  Jruby (JRuby) @ Wikipedia, ima težave s kompatibilnostjo napram MRI in C Rubyju, poleg tega žre več memorije in je počasnejši.  Groovy je pa tudi ena taka obskurna zadeva. Ti alternativni Java jeziki, IMHO niso na nivoju kot so .NET jeziki.  Če bi mi nekdo v ekipi predlagal, da gremo delat celoten komercialen produkt na Scali ali JRubyju bi ga brcnil v rit. Sam sem svojčas isto sanjal o teh zadevah, potem sem šel pa raziskovat in sem ugotovil, da zadeve enostavno niso zrele za resno (beri - for profit) uporabo.  Akademskim jezikom je skupno, da se ukvarjajo z novimi paradigmami in se posledično precej hitro in močno spreminjajo. Zaradi sorazmerno majhnih skupnosti so slabo podprti z knjižnicami, itd."
    },
    {
        "role": "assistant_5",
        "message": "@assistant_1 je 8. jan 2012 ob 12:13 izjavil:potem sem šel pa raziskovat in sem ugotovil, da zadeve enostavno niso zrele za resno (beri - for profit) uporabo..   twitter in ostali uporabniki scale se očitno ne strinjajo"
    },
    {
        "role": "assistant_1",
        "message": "Twitterjeva bilanca stanja se ne strinja s tabo.  Šalo na stran, Twitter je točno pravi usecase za Lisp like jezik, obdelava streamov/različnih množic obkjektov. Ravno tako je Twitter precej bolj akademski scenarij, kot pa naše vsakodnevne CRUD aplikacije.  Jaz recimo nebi šel CRUD aplikacije za stranko pisat v Scali, ker bi s tem stranko vrgel pod avtobus iz večih zornih kotov.  Problemi s katerimi se jaz ukvarjam za preživetje niso niti blizu Twitterju, isto drži za 90% razvijalcev. Ravno tako naše sposobnosti niso na istem nivoju kot onih fantov tam.  Saj nisem rekel, da se ne da ene take tipične Enterprise applikacije spisat v Scali. Samo, da to ni najbolj smotrno početje."
    },
    {
        "role": "assistant_1",
        "message": "http://www.artima.com/scalazine/article... (Iz konjevih ust, potrditev mojih tez).  Torej: Twitter ni 100% Scala, v Scalo so prepisali dele strežniške infrastrukture, kjer se Ruby ni obnesel najbolje (heavy lifting). Sicer je pa še vedno zelo veliko Twitterja na Rails plus ostali jeziki/platforme po potrebi.  Dajte se malo podučit fantje, preden streljate neumnosti."
    },
    {
        "role": "assistant_5",
        "message": "saj nisem rekel da je vse v scali nikjer =)"
    },
    {
        "role": "user",
        "message": "@assistant_1: Mislim da bi ta debata šla veliko boljše če bi ti takoj povedal da debatiraš s stališča pisanja glupih CRUD aplikacij, kjer je itak bolj ali manj vseeno če pišeš v COBOLu ali VB.NET. Prav tako bi morda bilo fajn če ne bi mešal \"vse\" .NET jezike z enim samim JVM jezikom :) Jabolke in hruške to.  Za pisanje kakšnih bolj kompleksnih kosov programja pa se začenjajo tile jeziki zelo opazno obrestovati, saj se zahtevnejši algoritmi pokrajšajo in v njih je manj skritih napak. Tu je tudi plac kjer JavaScript zelo grdo pogori, saj se mu zelo jasno vidi, da je ga je nekdo v omari zdesignal v enem tednu in v njem mrgoli nekonsistentnosti in skritih pasti (type coercion sistem je delal nekdo na LSDju, vstavljanje podpičij je kar en tak WTF, standardna knjižnica je čist shizofrena, pametna statična analiza kode pa je zaradi narave jezika praktično nemogoča) in posledično kljub morebitni večji ekspresivnosti za večje projekte niti zastarele Jave ne dohiti, kaj šele česa modernejšega."
    },
    {
        "role": "assistant_1",
        "message": "@user: Ja ampak samo tle na Slo-Techu so geniji, ki se ukvarjajo z naprednimi problemi. Razen mene, jaz pa 99% časa pišem CRUD aplikacije.  Za tist 1% ponavadi znam pogledat zadeve, je pa res da nisem taka faca kot ti, Arjan in @assistant_3, ki očitno vsi delate ali za Google, Twitter ali pa Zemanto :D."
    },
    {
        "role": "assistant_3",
        "message": "@assistant_1 je 8. jan 2012 ob 12:13 izjavil:Jruby (JRuby) @ Wikipedia, ima težave s kompatibilnostjo napram MRI in C Rubyju, poleg tega žre več memorije in je počasnejši.  Ne. Uporabljam JRuby in je production ready, je 100% kompatibilen z Ruby 1.8 specifikacijo pa tudi bistveno hitrejši je od MRIja. Glede performanc si lahko pogledaš tukaj http://file.si/public/viewset/77133 ali na Internetih. MRI ima tudi težave s porabo pomnilnika, ki pa so jih odpravili do neke mere v Ruby EE, vendar še vedno porabi več kot YARV. Ne vem pa če porabi več kot JRuby, ziher se pa najde kje na Internetih."
    },
    {
        "role": "assistant_1",
        "message": "David Ungar enkrat vmes (bolj na začetku) izjavi, da je prototipna inheritanca lepša in boljša od razredne.  http://my-inner-voice.blogspot.com/2012...  Eni bi mi pa to izpulil iz JavaScripta...  ccc"
    },
    {
        "role": "user",
        "message": "David Ungar pač nima pojma. Mutabilnost objektov, ki je ne moreš točno vedeti pri zagonu pač ustvarja nočno moro za testiranje, uspešno integracijo z IDEji in tudi za debuganje."
    },
    {
        "role": "assistant_1",
        "message": "David Ungar nima pojma?  Bolha pravi Slonu naj se umakne s poti?"
    },
    {
        "role": "assistant_0",
        "message": "On nima pojma in kr neki naklada. Teh gurujev je na tisoce, in te njihove futuristicne napovedi so 99% zgresene. Ti si pac najdu slucajno enega, ki hvali javascript in ker je tebi javascript tudi vsec, mislis zdej da model serje zlato."
    },
    {
        "role": "assistant_1",
        "message": "No sej, jst to čist verjamem - samo nisem pa vedel da mata ti pa @user boljše reference.  Kakšni so pa tvoji pogledi na prihodnost komputacijske paradigme? Kako bo zgledala komputacija v svetu tisočih in tisočih jeder? Predvidevam, da ti in @user stavita na supersinhrone pristope? Maš kak link do kakšnega svojega predavanja na to temo?  Al je vajino raziskovalno delo preveč tajno?"
    },
    {
        "role": "assistant_9",
        "message": "David Unger je priznan znanstvenik in izumitelj Selfa, prvega programskega jezika, ki je uporabljal \"prototipno dedovanje\". Itak da je pol pristaš tega pristopa, ki se uporablja tudi v JavaScriptu.  Jaz se ne bi postavljal na nobeno stran. Je pa dejstvo, da je \"razredno dedovanje\" trenutno bolj razširjen način objektno orientiranega programiranja. Prototype-based inheritance je verjetno težje za optimizirati in tako postavlja nove izzive (na podlagi katerih se bo najbrž tudi kaj novega odkrilo), tako da v akademskem smislu je zadeva definitivno kul. Glede na razširjenost JS se pa očitno tudi v produkciji obnese. Je pa vprašanje koliko ljudi se sploh zaveda tega aspekta JS...   Sicer je vse skupaj offtopic, me pa vseeno zanimajo stvari, ki jih je omenjal @assistant_1. Upam, da se bo iz tega razvila nova debata (fork) in tisto ni bilo mišljeno samo kot osebna diskvalifikacija nasprotnikov.  V zvezi s tem: kaj so \"supersinhroni pristopi\"?"
    },
    {
        "role": "assistant_9",
        "message": "@assistant_1 je 17. jan 2012 ob 09:02 izjavil:Kakšni so pa tvoji pogledi na prihodnost komputacijske paradigme V bistvu verjamem tistemu linku, ki si ga podal. Da bo mogoče doseči večji paralelizem, bo treba nekaj žrtvovati, recimo to da vedno dobiš natančen odgovor. Tako kot npr. CAP teorem v zvezi s porazdeljenimi podatki - ne moreš zadovoljiti vseh treh zahtev. Čisto mogoče, da je človeška pozabljivost in nezmožnost hitrega računanja z velikimi števili v bistvu \"optimizacija\", no ampak tole je že malo preveč filozofsko."
    },
    {
        "role": "assistant_1",
        "message": "@assistant_9: supersihnronost je pojem, ki sem se ga izmislil ob pisanju posta. Predstavlja pa logično nadgradnjo trenutnih locking mehanizmov na obsegu tisočev jeder.  V tem trenutku je že jasno, da je sinhronizacija največja cokla za nadaljni scaling obstoječih sekvenčnih paradigem, to drži za podatkovne baze in je znano že dlje časa (CAP teorem) na nivoju računskih komponent pa je zadnjih pet let jasno, da Moorov zakon drži in bo še naprej držal, nam pa to en falus pomaga pri sekvenčnih problemih. Še en zanimiv govor na to temo http://www.infoq.com/presentations/erla... Joe Armstrong (avtor Erlanga).  Glede mutabilnosti objektov bom pa dejal, da načeloma imaš prav @user. Vendar se v praksi izkaže, da imutabilnost le ni tako fajn, lep primer je recimo IOC pattern, ki ga dinamični jeziki ne poznajo.  Moje osebno mnenje je, da za večino vsakodnevnega dela so sodobni dinamični jeziki boljši, pod pogojem da veš kaj delaš. Zelencem pa ponujajo preveč možnosti za strel v nogo."
    },
    {
        "role": "assistant_5",
        "message": "kakšno povezavo ima imutabilnost, IOC in dinamični jeziki?"
    },
    {
        "role": "assistant_0",
        "message": "Moorov zakon ne drzi. Moorov zakon nima nobenih temeljev v realnosti, zato ni presenetljivo da ne drzi. Moorov zakon je to, da je en potegnu (fittal) eno krivuljo na zgodovinske podatke. Kar povsem ignorira to, da v realnosti na performanco racunalniskih sistemov vpliva veliko parametrov, ki jih moorov zakon povsem ignorira."
    },
    {
        "role": "assistant_1",
        "message": "@assistant_5: http://stackoverflow.com/questions/2908... Za začetek, naprej se boš pa že znašel.  @assistant_0: kaj si hotel sploh povedat?   V praksi je pač tako, da se na približno 18 mesecev gostota tranzistorjev na tiskanih vezjih podvoji ta pojav imenujemo Moorov zakon. Do pred petih let je ta pojav lepo koreliral s povečevanjem hitrosti integriranih vezij. Pred približno petimi leti, pa smo zadeli plato. Od tedaj naprej na 18 mesecev dobivamo manjša integrirana vezja z več računskimi enotami, katerih hitrost pa pri obstoječih arhitekturah ne narašča z isto funkcijo. Lahko rečemo jebi ga ali pa prilagodimo arhitekture in načine reševanja problemov novi realnosti. Prva stvar, ki bo morala leteti skozi okno je shared memory in z njim POSIX.  Kar se mene tiče bi rad v debato prinesel zavedanje, da srebrni metki ne obstajajo. Več znanja in informacij, več pristopov do reševanja problemov je lahko samo dobra stvar. Vsak ima svoje dobre lastnosti in slabosti, katere je treba razumeti.  Tle me ja pa par modelov napadlo, češ da širim krivo vero. Imate se za ful izkušene in modre, pa očitno niste tako izkušeni in modri, če še niste ugotovili te osnovne resnice.  Ali kot je dejal Sokrat: Vem da nič ne vem, vi pa še tega ne veste."
    },
    {
        "role": "assistant_5",
        "message": "@assistant_1 je 18. jan 2012 ob 19:57 izjavil:@assistant_5: http://stackoverflow.com/questions/2908... Za začetek, naprej se boš pa že znašel.    točno vem kaj je vsaka od teh stvari ampak tvoj stavek nima nobenega smisla"
    },
    {
        "role": "assistant_1",
        "message": "V bistvu sem hotel sem reči, da statičnost postane omejitev takoj, ko želiš postati nekoliko bolj kreativen. Primer takega flajštra je recimo IOC container vzorec. In danes programer večino časa štuka različne komponente skupaj. Seveda povsem odvisno od tega kaj delaš in katera sredstva imaš na razpolago.  Meni je še najbližje pristop, da štartaš z udobnim dinamičnim jezikom, potem pa po potrebi dodajaš/optimiziraš komponente tja do assemblerja če je treba.  Mutabilnost nima druge veze s tem razen da je še ena dualna lastnost. Izjava da dinamični jeziki nimajo IOC je pa oksimoron. Mea culpa."
    },
    {
        "role": "assistant_3",
        "message": "Imate se za ful izkušene in modre, pa očitno niste tako izkušeni in modri, če še niste ugotovili te osnovne resnice. Men se zdi da si ti @assistant_1 še najboljši primer take osebe, od vseh tukaj. Moraš imet čisto pri vsem prav in se ni možno kaj dosti konstruktivno pogovarjat."
    }
]