[
  {
    "message": "Lep pozdrav, ker se že en teden ukvarjam s to nalogo (brez uspeha), sem se odločil zatežit na ST forum, če bo kdo svetoval :)  V zbirnem jeziku napišite rekurzivno funkcijo, ki izračuna n-ti člen zaporedja:  f(n) = f(n-3) + f(n-2), n > 2, f(0) = 1, f(1)=1, f(2) = 7  Naredil sem že okoli 5 verzij pa mi nobena ne dela. Spodnja je še najboljši približek (vendar na koncu zašteka - \"Cannot read memory at 0x0000001\")   bits 32\nextern _printf\nglobal _main\n\nsection .data\n\tizpis db \"Rezultat za f(%d)= %d\",10,0 ;za izpis zaporedja\n\tn dd 0\n\t\nsection .text\n\t_rekurz:\t\t\n\t\tmov eax, [esp+4]   \t   ;trenutni argument shranimo v eax\n\n\t\tcmp eax,0\t\t\t\t;primerjamo, če je argument 0 in v tem primeru v eax shranimo 1\n\t\tje .vrni1\n\t\t\n\t\tcmp eax,1\n\t\tje .vrni1\n\t\t\n\t\tcmp eax,2\t\t\t\t;primerjamo argument z 2\n\t\tje .vrni7\n\t\t\n\t\tsub eax,2\t\t\t;n=n-2\n\t\tmov edx, eax\t\t;eax (n) shranimo v drug register, saj se bo vrednost eax spremenila\n\t\tpush eax\t\t\t;na sklad potisnemo eax (n-2)\n\t\tcall _rekurz\t\t;klicemo funkcijo za trenutni (n-2) - rezultat bo v eax\n\t\tadd esp,4\t\t\t;pobrišemo argument\n\t\tmov ecx,eax\t\t\t;dobljeno vrednost shranimo v ecx, začasno\n\t\t\n\t\tmov eax,edx\t\t\t;v eax nazaj shrani tisti trenutni n (n-2)\n\t\tdec eax\t\t\t\t;in se zmanjsamo za 1 (n-2 -1 = n-3)\n\t\tpush eax\t\t\t;in to potisnemo na sklad na naslednji klic\n\t\tcall _rekurz\t\t;klicemo funkcijo za trenutni (n-3) - rezultat bo v eax\n\t\tadd esp,4\t\n\t\t\n\t\tadd eax,ecx\t\t\t;rezultata seštejemo\n\t\t\n\t\tret\n\t\t\t\n\t.vrni1:\n\t\tmov eax,1\n\t\tret\n\t\t\n\t.vrni7:\n\t\tmov eax,7\n\t\tret\n\t\t\n\t.konec:\n\t\tret\n\t\t\n\t_main:\n\t\tpushad\n\t\t\n\t\t; klic funkcije - rad bi izracunal 10. clen\n\t\tpush 10\n\t\tcall _rekurz\n\t\tadd esp,4\n\t\t\n\t\t; izpis rezultata\n\t\tpush eax\n\t\tpush 10\n\t\tpush dword izpis\n\t\tcall _printf\n\t\tadd esp, 8\n\t\t\n\t\tpopad\n\t\tret\n\t\t\n\t\t\n\t\t ",
    "user": "c0dehunter"
  },
  {
    "message": "lp   mov edx, eax        ;eax (n) shranimo v drug register, saj se bo vrednost eax spremenila\n Ta n se bo ob rekurzivnem klicu vedno znova spremeninjal(tudi v registru ker ga vedno znova tja shranjujes).. Torej to je ena napaka  vrednost moras shranit v sklad.. torej najprej ko v register preneses parameter, preveris pogoje(ce je 0 1 ali 2).. potem pa v sklad pushas: - rezerviran prostor za rezultat - n-2(od shranjene vrednosti v registru odstejes 2) - n-3 No in pol rekurzivno klices funkcijo.parameter se vzame n-3. rezultat shranis na rezerviran prostor, pocistis vrh sklada, spet klices rekurzivno funkcijo(parameter n-2) in na koncu vrnjeno vrednost eax pristejes k prvem rezultatu. ",
    "user": "mikesr"
  },
  {
    "message": "mikser, 100x hvala!  Edino tega ne razumem najbolj: \"potem pa v sklad pushas: -rezerviran prostor za rezultat\". Lahko to malo bolj razložiš? Sumim, da se to nanaša na   mov ecx,eax         ;dobljeno vrednost shranimo v ecx, začasno , vendar ne vem kako implementirat.  Sedanja koda (rekurzivne funkcije) - rezultat še vedno ni prav:  _rekurz:\t\t\n\t\tmov eax, [esp+4]   \t   ;trenutni argument shranimo v eax\n\n\t\tcmp eax,0\t\t\t\t;primerjamo, če je argument 0 in v tem primeru v eax shranimo 1\n\t\tje .vrni1\n\t\t\n\t\tcmp eax,1\n\t\tje .vrni1\n\t\t\n\t\tcmp eax,2\t\t\t\t;primerjamo argument z 2\n\t\tje .vrni7\n\t\t\n\t\tsub eax,2\t\t\t;n=n-2\n\t\tpush eax\t\t\t;eax (n) shranimo na sklad, saj se bo vrednost eax spremenila\n\t\tdec eax\n\t\tpush eax\t\t\t;n=n-3\n\t\t\n\t\tcall _rekurz\t\t;klicemo funkcijo za trenutni (n-3) - rezultat bo v eax\n\t\tadd esp,4\t\t\t;pobrišemo argument\n\t\tmov esi,eax\t\t\t;dobljeno vrednost shranimo v esi, začasno\n\n\t\tcall _rekurz\t\t;klicemo funkcijo za trenutni (n-3) - rezultat bo v eax\n\t\tadd esp,4\n\n\t\tadd eax,esi\t\t\t;rezultata seštejemo\n\t\t\n\t\tret ",
    "user": "c0dehunter"
  },
  {
    "message": " ;V zbirnem jeziku napišite rekurzivno funkcijo, ki izračuna n-ti člen zaporedja:\n;f(n) = f(n-3) + f(n-2), n > 2, f(0) = 1, f(1)=1, f(2) = 7\n;V glavnem programu izračunajte člene od 3 do 15 in rezultat izpišite.\n;Pomoč: dogovor klica funkcije cdecl, organizacija funkcijskega klicnega okna.\n\nbits 32\nextern printf\nglobal main\n\nsection .data\n  izpis db \"f(%d)=%d\",10,0\n  stevec dd 0\n\nmain:\n  pushad\n  mov dword [stevec], 3          ;stevec nastavimo na 3\n  .zanka:                        ;loop \n  push dword [stevec]\t\t ;stevec pushnemo na sklad\n  call funkcija                  ;klic funkcije\n  add esp, 4                     ;pocistimo za sabo\n  push eax                       ;eax in stevec na sklad + izpis\n  push dword [stevec]            \n  push izpis\n  call printf\n  add esp, 12\t\t\t ;pocistimo, ker smo 3 pushnili na sklad po 4bajte\n  inc dword [stevec]             ;stevec povecujemo za 1\n  cmp dword [stevec], 15         ;to delamo dokler ne dosezemo 15, potem koncamo\n  jle .zanka\n  popad\n  ret\n\nfunkcija:\t\t\t;funkcija\n    mov eax, [esp+4]            ;trenutni argument shranimo v eax\n    cmp eax, 0\t\t        ;eax primerjamo z 0, ce je 0 jump v nadaljuj1, drugace shrani 1 v eax\n    jg .nadaljuj1\n    mov eax, 1         \n    jmp .konec\n  .nadaljuj1:                   ;nadaljuj1\n    cmp eax, 1                  ;eax primerjamo z 1.. ce je enak 1 gremo v nadaljuj2, drugace\n    jg .nadaljuj2\n    mov eax, 1                  ;v eax damo 1\n    jmp .konec\n  .nadaljuj2:                   ;nadaljuj2\n    cmp eax, 2                  ;ce je eax 2 gremo v nadaljuj 3 \n    jg .nadaljuj3\n    mov eax, 7                  ;v eax damo 7\n    jmp .konec                  ;skok na konec\n  .nadaljuj3:                   ;nadaljuj3\n    sub eax, 2                  ;(eax-2)\n    push eax                    ;damo na sklad\n    sub eax, 1                  ;odstejemo se 1... (eax-3)\n    push eax                    ;damo na sklad za naslednji klic\n    call funkcija               ;klicemo funkcijo, rezultat se shrani v eax\n    add esp, 4                  ;pocistimo\n    pop ebx                     \n    push eax                    ;eax in ebx damo na sklad\n    push ebx\n    call funkcija               ;klic funkcije, rezultata seštejemo \n    add esp, 4\n    add eax, dword [esp]\n    add esp, 4\n  .konec:\n    ret\n  Zanima me, če mi lahko kdo razlozi zadnjih par vrstic kode.. pop ebx pa add eax, dword [esp].. Kaj tu naredimo.. Ni mi čisto jasno? Zakaj kar ebx, od kje? ",
    "user": "bigbada"
  },
  {
    "message": "lp sosolci   bom kar prilepil kodo, da bo bolj razumljivo:        \n      push 0           ;rezultat , lahko je tudi sub esp, 4\n      sub ecx, 2       ;(n-2)\n      push ecx         ;shranimo v sklad\n      sub ecx, 1       ;(n-3)\n      push ecx         ;shranimo v sklad\n\n      call _rekurzija   ;klic funkcije z n-3 parametrom\n      add [esp+8], eax  ;rezultat shranimo v sklad(na rezerviran prostor)\n      add esp, 4        ;izbrisemo vrh sklada(n-3)\n\n      call _rekurzija    ;klic funkcije z n-2 parametrom\n      add eax, [esp+4]   ;rezultat + prej shranjenen rezultat\n      add esp, 8         ;pocistimo sklad\n ",
    "user": "mikesr"
  },
  {
    "message": "Aha, zdaj mi je pa jasno :) Sem preštudiral, popravu kodo in zdej dela. Hvala! ",
    "user": "c0dehunter"
  }
]